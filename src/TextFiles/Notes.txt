import java.util.Collections;
import java.util.List;

String[] st = s.split(" ");
Arrays.sort(st, (a, b) -> (int) a.charAt(a.length() - 1) - (int) b.charAt(b.length() - 1));
return Arrays.stream(st).map(str -> str.substring(0, str.length() - 1)).collect(Collectors.joining(" "));


new StringBuilder("hello").charAt(), .setCharAt(), .deleteCharAt();


String st1 = String.join("", word1);


s1,s2 stringBuilder
s1.toString().equals(s2.toString());

public String toLowerCase(String str) {
        char[] a = str.toCharArray();
        for (int i = 0; i < a.length; i++)
            if ('A' <= a[i] && a[i] <= 'Z')
                a[i] = (char) (a[i] - 'A' + 'a');
        return new String(a);
    }

if(c >='a' && c<='z') c = c-'a' + 'A';
else if(c>='A' && c<='Z') c = c-'A' + 'a';


String str = "testString";
char[] charArray = str.toCharArray();
Character[] charObjectArray = ArrayUtils.toObject(charArray);

Character[] charObjectArray =
    str.chars().mapToObj(c -> (char)c).toArray(Character[]::new);


"     ".chars().mapToObj(c -> (char) c).toArray(Character[]::new);
int U = Collections.frequency(List.of(array), 'U');

public String convertToTitle(int columnNumber) {
        StringBuilder sb = new StringBuilder();
        int reminder = 0;
        while (columnNumber > 0) {
            if (columnNumber % 26 == 0) {
                reminder = 26;
                columnNumber--;
            } else {
                reminder = columnNumber % 26;
            }
            sb.append((char) ('A' + reminder - 1));
            columnNumber /= 26;
        }
        return sb.reverse().toString();
    }


" ".contentEquals(new StringBuilder());


Character.isLetterOrDigit(ch)
Character.isDigit(s.charAt(i)


Deque<Character> stack = new ArrayDeque<>(); in java

int j = (int) Math.sqrt(c);

Map<Character, Integer> map =
        Map.of(
            'I', 1,
            'V', 5)



 Queue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);
 PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> b[0] - a[0]);
 for (int i = 0; i < pq.size(); i++)
		{
            System.out.println("peeking " + Arrays.toString(pq.peek()));
            pq.poll();
        }
        System.out.println();


 Pairs in java, nothing but create a class to store two values vai constructor



problem 1552 :
This problem is based upon Aggressive Cows problem.
Similar questions on LEETCODE are :

Ques. No. 1552
Ques. No. 1870
Ques. No. 875
Ques. No. 1283
Ques. No. 1482
Ques. No. 2064
-----------------------------------------------------
If you haven't solved it all yet, here's the list to practice (for future readers!)
BS special case: LC Study Guide: Binary Search on Answer : https://leetcode.com/discuss/study-guide/3444552/binary-search-on-answer-template-generic-template
Must do to master the binary search on answer:

https://leetcode.com/problems/minimum-time-to-repair-cars/ <-- this one is gold!!!
https://leetcode.com/problems/minimum-speed-to-arrive-on-time/
https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/
https://leetcode.com/problems/koko-eating-bananas/
https://leetcode.com/problems/maximum-candies-allocated-to-k-children/
https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/
https://leetcode.com/problems/sell-diminishing-valued-colored-balls/
https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/
https://leetcode.com/problems/divide-chocolate/ <-- this one is gold!!! (hard)




by the way, 1E6 means 1 times 10 to the power 6, which is 1.000.000, not 100.000.
2E8 means 2 times 10 to the power 8, or 200.000.000 (two hundred million). It's simple: 1E6 = 1 followed by 6 zeroes; 2E8 = 2 followed by 8 zeroes.
double v = 1E6;
int end = (int) 1E6;


public static int intCeil(int a, int b)
	{
      if (a % b != 0) {
        return (a / b) + 1;
      } else {
        return (a / b);
      }
    }
OR double result = Math.ceil(number);



Arrays.setAll(nums, i -> ((nums[i] & 1) == 1) ? 1 : 0);


HashMap<Integer, Integer> map = new HashMap<>();
count += map.getOrDefault(key, 0);


Not synchronized: By default, the ArrayDeque class
is not synchronized, which means that multiple threads can access it simultaneously, leading to potential data corruption.

Features:
Array deques have no capacity restrictions and they grow as necessary to support usage.
They are not thread-safe which means that in the absence of external synchronization, ArrayDeque does not support concurrent access by multiple threads.
Null elements are prohibited in the ArrayDeque.
ArrayDeque class is likely to be faster than Stack when used as a stack.
ArrayDeque class is likely to be faster than LinkedList when used as a queue.


for (int i = 0; i < ceil; i++) sb.append(a);
        sb.append(a.repeat(Math.max(0, ceil)));


char[] arr = String.valueOf(n).toCharArray();
Arrays.sort(arr, i + 1, arr.length);

=========================================================================================================================================

PEMDAS: Parenthesis -> Exponents -> Multiplication and Division (left to right) -> Addition and Subtraction (left to right).
BODMAS: Brackets -> Divison-> Multiplication -> Addition -> Substraction.

+ Addition
- Subtraction
* Multiplication
/ Division
^ Exponents (2^5 is 2 raised to the power of 5)
r Roots (2r3 is the 3rd root of 2)
() [] {} Brackets or Grouping



public int countHomogenous(String s) {
        long count = 1;
        long sum = 1;
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == s.charAt(i - 1)) {
                count++;
            }else {
                count = 1;
            }
            sum += count;
        }
        return  (int) (sum % 1_000_000_007);
    }


" T   "stripTrailing();

		int[] arr	= {5, 2, 3, 1};
List<Integer> list1	= Arrays.stream(arr).boxed().toList();
		int[] array	= list.stream().mapToInt(n -> n).toArray();


class {
	public static void main(args[] str){

		PriorityQueue<Integer> minHeap=new PriorityQueue<>();
		PriorityQueue<Integer> maxHeap=new PriorityQueue<>(Collections.reverseOrder());
		PriorityQueue<Integer> maxHeap2=new PriorityQueue<>((a, b) -> b-a);
		// if we stor maximum k values in minHeap and keep on adding values and poll if size >4
		// then it will keep on polling min values and minHeap will contain max k values in it.
	}
}


The bitCount() method of Integer class of java.lang package returns the count of set bits in a positive number.

Integer.bitCount()
Integer. ..............

===============================================================
& is AND Operation (1 AND 1 is 1, 1 AND 0 is 0, 0 AND 0 is 0)
     num & 1 == 1 meaning odd, == 0 meaning even.
     Example:
		 n = 15 or 1111. n & 0001 = 0001
		 n = 8 or 1000. n & 0001 = 0000

^ is XOR Operation (1 OR 1 is 0, 1 OR 0 is 1, 0 OR 0 is 0)
     num ^ 1 is num - 1 if num is odd, or num + 1 if num is even.
     We only use num ^ 1 when num is odd.
     Example:
	 	n = 15 or 1111. n ^ 0001 = 1110 (14)
	 	n = 8 or 1000. n ^ 0001 = 1001 (9)


>> is SHIFT RIGHT Operation, the number is the number of bits moved (moving the whole binary one bit right).
     num >> 1 is num / 2 if num is even. If num is odd, then is (num - 1) / 2.
     Example:
		 n = 15 or 1111. n >> 1 = 0111 (7)
		 n = 8 or 1000. n >> 1 = 0100 (4)

Hence :
while (num > 0) {
            num = (num & 1) == 1 ? num ^ 1 : num >> 1;
            count++;
        }
===============================================================
private static void printSubsets(String op, String ip) {
        if (ip.isEmpty()) {
            list.add(op); return;
        }
        printSubsets(op, 				ip.substring(1));
        printSubsets(op+ip.charAt(0),	ip.substring(1));
    }

========================
Kadane's Algorithm :

I spent some time convincing myself about why we need to reset to zero. By reseting maxCur to 0,
 essentially it means that we have found a point i where the price[i] is lower than the time we bought,
 and that we should then try to buy at point i to see if we can achieve a bigger gain.
 Because maxCur is recording the difference, the difference between price[i] and itself should be 0.


Fantastic Explanation! Plus my own understanding, the recording of the sum of
differences is to eliminate the fluctuations in the middle. So if maxCur is negative,
then a cheaper price must have been encountered.


// compare two very big integer using lexography of String, no need to use number container
private static String compare(String s1, char[] arr) {
        String s2 = String.valueOf(arr);
        return s1.compareTo(s2) > 0 ? s1 : s2;
    }

============================================================
 int n = "(ed(et(oc))el)".length();
        StringBuilder result = new StringBuilder();
        int direction = 1; // Left to Right
        for (int i = 0; i < n; i += direction) {
            if (s.charAt(i) == '(' || s.charAt(i) == ')') {
                i = door[i];
                direction = -direction;
            } else {
                result.append(s.charAt(i));
            }
        }
============================================================


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


public static int getFirstSetBitPos(int n)
    {
        return (int)((Math.log10(n & -n)) / Math.log10(2))
            + 1;
    }

============================================================
System.out.println(addBinary2("100", "110010"));

public static String addBinary2(String a, String b) {
        StringBuilder sb = new StringBuilder();
        int carry = 0, base = 2;
        int p1 = a.length() - 1;
        int p2 = b.length() - 1;
        while (p1 >= 0 || p2 >= 0 || carry == 1) {
            int n1 = p1 >= 0 ? a.charAt(p1--) - '0' : 0;
            int n2 = p2 >= 0 ? b.charAt(p2--) - '0' : 0;
            int sum = n1 + n2 + carry;
            sb.append(sum % base);
            carry = sum / base;
        }
        return sb.reverse().toString();
    }
============================================================

   while (p1 >= 0 || p2 >= 0) {
            int n1 = p1 >= 0 ? a.charAt(p1--) - '0' : 0;
            int n2 = p2 >= 0 ? b.charAt(p2--) - '0' : 0;


#
TimeUnit.SECONDS.sleep(1);

to create 1111 with length 4
int mask = (1 << length) - 1; => 10000 - 1 => 1111

=========================Records in JAVA===================================
public record data1(String key, Integer value) {}
public record data2<K, V>(K key, V value) {}

* whole purpose is to hold data in itself, data will be immutable.

* defines the variable as final and nonstatic, takes from record creation itself.

* it automatically creates a defualt constructor with given values in record creation paramaeter
	and thic constuctor is called colonical constructor.

* Record has defaut variable as final so it does not want them to be used by other classes as a
	relation hence it is final and doesn't let anyone extend it.

* we can have our static and nonstatic method inside it and later can be used.

* we can also define our feild, but guess what: non static wouldnt be allower as in record all
	nonstatic are created as record creation time and they are final as they can not be changed.

* these classes implicitly extends Record class hence another one(multiple inheritence) by us is
	not possible but we can obviously implements interfaces.

* We can create our own constructor but it has to follow the given fields and order of fields that
	were there while record was created with theri assignment to record variables.

* Unique : Here inside record we can create a method without any paranthesis as a constructor as
	compiler knows it will has same parameter field and even done need to intialize our variable,
	compiler we do that for us
	public record {
		if(value < 0) throw exception;
	}


=========================Generic Method in JAVA===================================

Creating a Generic Method in Java
The angle bracket syntax is required to declare a type parameter when writing a generic method in Java.
A placeholder for the real type that will be supplied to the method at runtime is the type argument.

Syntax for Declaring a Generic Method:
public <T> void methodName(T parameter) {
    // method implementation
}

public static <T, U> boolean isEqual(T arg1, U arg2) {
    return arg1.equals(arg2);
}

	isEqual(10, 10) 			// true
    isEqual("hello", "world") 	// false
    isEqual(3.14, 3.14) 		// true
public static <T> boolean isEqual(T obj1, T obj2) {
        return obj1.equals(obj2);
}

we can define a generic method that only works with objects that implement the Comparable interface,
which provides a way to compare objects of the same type. Here is an example:
public static void main(String[] args) {
        System.out.println(isGreaterThan(10, 5)); // true
        System.out.println(isGreaterThan("hello", "world")); // false
        System.out.println(isGreaterThan(3.14, 2.5)); // true
    }
    public static <T extends Comparable<T>> boolean isGreaterThan(T arg1, T arg2) {
        return arg1.compareTo(arg2) > 0;
    }

==================================================================================

if		num[i]				= arr[i] XOR arr[i+1]
then	num[i] XOR arr[i]	= arr[i+1]

if		a		= b XOR c
then	a XOR c	= b
==================================================================================

final boolean sign = dividend > 0 ^ divisor > 0;

==================================================================================

		String[] names = {"Java", "Node", "JavaScript", "Rust", "Go"};
        List<String> collect = IntStream.range(0, names.length)
                                        .mapToObj(index -> index + ":" + names[index])
                                        .collect(Collectors.toList());
        collect.forEach(System.out::println);

IntStream.range(0, obj.dp.length)
                 .mapToObj(index -> index + ":" + obj.dp[index])
                 .forEach(System.out::println);


==================================================================================
public static void main(String[] args) {
        HashMap map = new HashMap<>();

        map.merge("A", 1, Integer::sum); // Inserts new entry with key "A" and value 1
        //map -> {"A": 1}

        map.merge("A", 2, Integer::sum);
        // Inserts new entry with key "A" and value 2, but since key "A" already exist it will merge the value
        //map -> {"A": 3}

        System.out.println(map);
		//{A=3}
    }


Explanation:

In this example, the merge() method is used to insert an entry with key "A" and value 1 into the map,
then it insert another entry with key "A" and value 2. Since key "A" already present in the map,
the function Integer::sum is used to compute the new value for the key.
it will merge the value by adding the existing value (1) and the new value (2) , the new value is 3.

Hence :

		String[] arr = {"a", "b", "a", "a", "b", "a"};

		HashMap<String, Integer> map = new HashMap<>();

		for (String s : arr) {
            map.merge(s, 1, Integer::sum);
        }

        System.out.println("map = " + map);
		//map = {a=4, b=2}

==================================================================================

1900 is not a leap year but 1600 is a leap year!!!
private boolean isLeapYear(int year) {
        return (year % 4 == 0 && year % 100 != 0) || year % 400 == 0;
    }


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================


==================================================================================




















































































































































































































































































































































